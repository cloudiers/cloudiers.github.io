### 12.1、为什么要类型转换

不同数据类型的操作数进行运算时，为了避免不可预测的错误发生，引入了类型转换

分两类:

- 自动转换(隐式转换)
- 强制转换(显示转换)

![[_attachments/Pasted image 20250114141834.png]]

### 12.2、自动转换(隐式转换)

发生在不同数据类型的量混合运算时，由编译系统自动完成

自动转换的方向:

![[_attachments/Pasted image 20250114141839.png]]

1.若参与运算量的类型不同，则先转换成同一类型，然后进行运算

> 例如 `2.3+1`
>
> 因为`2.3`的数据类型和 `1` 的数据类型不一样，所以为了计算方便编译器自动进行转换

2.转换按数据长度增加的方向进行转换，以保证精度不降低

> 如`int`型和`long`型运算时，先把`int`量转成`long`型，再进行运算

3.所有的浮点运算都是以`双精度`进行的，即使仅含float单精度量运算的表达式，也要先转换成 `double`型，再作运算

4.`char`型和`short`型参与运算时，必须先转换成`int`型

> 例如： `'a'+1`
>
> 为什么char 类型先转化成int类型呢？ 在内存中字符的存储实际上是把字符相对应的ASCII代码放到存储单元中的。而这些ASCII代码值在计算机中也是以二进制形式存放的。这个与整型的存储很相似。因此这两类之间的转换也比较方便。

5.在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型，如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度

> `int a = 2.3 + 1;`
>
> `int b = 2.6 + 1;` (亲测)小数点干掉

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    int a = 2.3 + 1;
    int b = 2.6 + 1;

    printf("a=%d\n", a);
    printf("b=%d\n", b);
    return 0;
}
```

![[_attachments/Pasted image 20250113102609.png]]

### 12.3、强制类型转换(显示转换)

是通过类型转换运算来实现的，其一般形式为:

```c
(类型说明符) (表达式)
```

其功能是：把表达式的运算结果强制转换成类型说明符所表示的类型

```c
(float) a;  // 把a转换为实型
(int)(x+y);  // 把x+y的结果转换为整型
```

类似如下形式

![[_attachments/Pasted image 20250113102621.png]]

### [注意](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/1.15.changetype?id=%e6%b3%a8%e6%84%8f)

- 类型说明符和表达式都必须加括号(单个变量可以不加括号),如把`(int)(x+y)`写成`(int)x+y` 则成了把`x`转换成`int`型之后再与`y`相加了
- 无论是强制转换或是自动转换，都只是为了本次运算的需要而对变量的数据长度进行的`临时性转换`，而`不改变在定义的类型`

![[_attachments/Pasted image 20250113102636.png]]
