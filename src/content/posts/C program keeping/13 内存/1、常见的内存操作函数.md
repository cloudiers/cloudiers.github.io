## [1. 为什么要申请内存？](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_1-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%b3%e8%af%b7%e5%86%85%e5%ad%98%ef%bc%9f)

程序中定义的变量，在编译阶段就已经分配好了，此方式为：`静态分配`

如果在程序运行过程中 申请的内存空间的方式为：`动态分配`

以数组为例，数组的大小在编译阶段就已经确定了，实际开发中有些 情况下使用这种方式是不方便的，例如使用数组在存储班级中所有学生的成绩，但是不同班级的学生的数量是不同，在这种情况下，应该 给该数组分配多大的内存??？

一般是按照可以容纳可能出现的最多元素来做

优点：简单

缺点：声明中引入了限制，如果程序需要使用的元素超过声明的长度，怎么办??

1）解决上一个缺点的方法就是把数组声明的更大一些，但是同时新的缺点又出现了，如果程序实际需要的元素数量比较少时，这样绝大部分的内存空间都被浪费

2）如果超过数组容纳的范围时，此时程序会崩溃

## [2. 常见内存操作函数](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_2-%e5%b8%b8%e8%a7%81%e5%86%85%e5%ad%98%e6%93%8d%e4%bd%9c%e5%87%bd%e6%95%b0)

C语言中提供了三个动态分配内存的函数：`malloc`、`calloc`和`realloc`

需要包含头文件：`<stdlib.h>`

### [2.1 `malloc`](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_21-malloc)

```
void *malloc(unsigned size)
```

- 作用：是在内存的堆区分配一个 大小为`size`的连续空间，如果分配内存成功，函数返回新分配内存的首地址，否则返回 `NULL`

- 说明：`size`是指的分配内存的字节，`void *` 类型的指针叫`通用指针`，可以指向任何的变量，C语言允许直接把任何变量的地址作为指针赋给通用指针
- 注意：一般在写程序需要判断分配内存是否成功

```
int *p;
p = (int *)malloc(sizeof(int));
if (p != NULL){
    //分配内存成功时，需要执行的语句
}else {
    //分配内存不成功，需要执行的语句
}
```

#### [示例](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=%e7%a4%ba%e4%be%8b)

```c
//
// Created by wangmingdong on 2023/6/8.
//
#include "stdio.h"
#include "stdlib.h"

int main() {

    int *p = NULL;

    p = (int *) malloc(sizeof(int) * 40);
    if (p != NULL) {
        *p = 10;
        *(p + 1) = 20;
        printf("*p=%d\n", *p);
        printf("*(p+1)=%d\n", *(p + 1));
    } else {
        printf("内存申请失败....n");
    }


    return 0;
}

```

### [2.2 `memset`](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_22-memset)

```c
void * memset(void *s, int c, size_t n);
```

功能：`memset()`会将参数`s`所指的内存区域前`n`个字节以参数`c`(ASCII 码值) 填入

返回值：返回指向`s` 的指针

注意：参数 `c` 虽声明为`int`,但必须是`unsigned char`即范围在`0` 到 `255` 之间

```c
//
// Created by wangmingdong on 2023/6/8.
//
#include "stdio.h"
#include "stdlib.h"

int main() {

    int *p = NULL;
    // 申请4*40个字节内存
    p = (int *) malloc(sizeof(int) * 40);
    if (p != NULL) {
        for (int i = 0; i < 40; i++) {
            printf("第%d个数值:%d\n", i, *(p + i));
        }
    } else {
        printf("内存申请失败....n");
    }

    return 0;
}

```

![[_attachments/Pasted image 20250114144830.png]]

使用memset进行设置默认值，效果如下

![[_attachments/Pasted image 20250114144836.png]]

### [2.3 `calloc`](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_23-calloc)

```c
void* calloc(unsigned n, unsigned size)
```

功能：申请内存，且自动初始化为默认值0

说明：

- `n`：表示需要分配内存的数据项个数
- `size`：指每个数据项的大小

返回值：申请后的内存地址

示例

![[_attachments/Pasted image 20250114144845.png]]

### [2.4 `realloc`](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_24-realloc)

```c
void *realloc(void*str, unsigned size);
```

功能：将`str`所指的已分配内存区的大小改为`size`

`size` 可以比原来分配的内存空间小或大

如果重新分配成功则返回指向被分配内存的指针，否则返回 空指针`NULL`

`realloc`可以对给定的指针所指的空间进行扩大或者缩小，如果是扩张，原有内存的中内容将保持不变如果是缩小，则被缩小的那一部分的内容会丢失

注意：

- `realloc` 并不保证调整后的内存空间和原来的内存空间保持同一内存地址
- `realloc` 返回的指针很可能指向一个新的地址，所以在代码中，必须将`realloc`返回的值重新赋值给对应的变量

示例

```c
//
// Created by wangmingdong on 2023/6/8.
//
#include "stdio.h"
#include "stdlib.h"

int main() {

    int *p = (int *) malloc(sizeof(int) * 5);
    *p = 60;
    *(p + 1) = 70;
    *(p + 2) = 80;
    *(p + 3) = 90;
    *(p + 4) = 100;

    // 如果有1个新的同学加入，需要额外申请1个int空间，因此需要使用realloc操作
    p = realloc(p, sizeof(int) * 6);
    *(p + 5) = 88;

    // 遍历所有分数
    for (int i = 0; i < 6; i++) {
        printf("第%d名分数：%d\n", i + 1, *(p + i));
    }

    return 0;
}
```

![[_attachments/Pasted image 20250114144856.png]]

## [3. 内存泄漏](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_3-%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f)

分析如下代码：内存是否释放？

```c
//
// Created by wangmingdong on 2023/6/8.
//
#include "stdio.h"
#include "stdlib.h"

int main() {

    int *p = (int *) malloc(sizeof(int) * 5);

    return 0;
}
```

说明： 如果已经成功的向系统申请了一定的内存空间，当这块内存空间不再使用时，应该归还给系统，否则，就会产生内存泄漏

解决办法： 在指针变量`p`被释放之前，先把指针变量p指向的这块内存空间给释放

## [4. `free`](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=_4-free)

```c
void free(void *ptr);
```

说明：参数 `ptr` 为指向先前由`malloc()`、`calloc()`或`realloc()`所返回的内存指针

调用 `free()`后`ptr`所指的内存空间便会被收回

```c
//
// Created by wangmingdong on 2023/6/8.
//
#include "stdio.h"
#include "stdlib.h"

int main() {

    int *p = (int *) malloc(sizeof(int) * 5);
    free(p);  // 释放p指向的内存
    return 0;
}
```

#### [注意：](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.1.malloc?id=%e6%b3%a8%e6%84%8f%ef%bc%9a)

- 若参数`ptr` 所指的内存空间已被收回或是未知的内存地址，则调用 `free()`可能会发生无法预期的情况
- 若参数`ptr` 为`NULL`，则`free()`不会有任何作用
