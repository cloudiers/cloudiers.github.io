## [1. 思考](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.4.size.struct?id=_1-%e6%80%9d%e8%80%83)

如下图所示，结构体变量`test`占用的内存空间是`6`（即1+4+1）吗？

![[_attachments/Pasted image 20250114143703.png]]

## [2. 结构体存储原理](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.4.size.struct?id=_2-%e7%bb%93%e6%9e%84%e4%bd%93%e5%ad%98%e5%82%a8%e5%8e%9f%e7%90%86)

`32`/`64`位系统中，`int`型被对齐为`4`个字节的地址边界。 保证了一个`int`型的数总能通过一次内存操作就能获取到。 每次访问是`4`字节对齐的地址处，读取或存入4个字节的整数。 每次读`4`个字节这种方式比较方便

如果按照4个字节读取数据，那么在取结构体中的成员的数据时，可能会带来性能的损失，如下图

![[_attachments/Pasted image 20250114143709.png]]

每次按照四字节进行读取，在读取`m2`的时候就需要读取两次（即上图中红 色箭头分为的`2`部分），而且读取出来的数据还要进行拼装（取第一次数据的后`3`个字节，取后一次数据的前`1`个字节），这就进行了额外的操作， 导致系统性能下降

为了提高计算机运算的销量，计算机采用字节对齐的方式来“浪费”一定 的内存空间，换取更高的效率

综上所述，上图程序中的结果不是`6`，而是按照字节对齐之后的答案 `12`

![[_attachments/Pasted image 20250114143716.png]]

## [3. 测量结构体变量大小](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.4.size.struct?id=_3-%e6%b5%8b%e9%87%8f%e7%bb%93%e6%9e%84%e4%bd%93%e5%8f%98%e9%87%8f%e5%a4%a7%e5%b0%8f)

测试示例1：

![[_attachments/Pasted image 20250114143723.png]]

测试示例2：

![[_attachments/Pasted image 20250114143731.png]]

### [空间大小计算规则：](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.4.size.struct?id=%e7%a9%ba%e9%97%b4%e5%a4%a7%e5%b0%8f%e8%ae%a1%e7%ae%97%e8%a7%84%e5%88%99%ef%bc%9a)

1.先找对齐模数(该结构体中 基本数据类型占用字节数最大那个);

2.按照存储顺序将各个元素进行存储,进行补齐字节

3.计算最终结果

## [4. 练习](https://doc.itprojects.cn/0004.zhishi.c/0002.doc/index.html#/8.4.size.struct?id=_4-%e7%bb%83%e4%b9%a0)

```c
#include "stdio.h"

struct stu {
    char a;
    short b;
    char c;
    int d;
    //double e;
};

int main() {

    struct stu boy = {0x11, 0x2233, 0x33, 0x44556677};

    printf("sizeof(boy)=%d\n", sizeof(boy));
    char *p = &boy;
    for (int i = 0; i < sizeof(boy); i++) {
        printf("[%d] 0x%x\n", i, *(p + i));
    }

    return 0;
}
```

运行结果

![[_attachments/Pasted image 20250114143739.png]]
